package aws_sdk

import (
	"errors"
	"fmt"
	"net/http"

	"github.com/aws/aws-sdk-go-v2/aws"
	awshttp "github.com/aws/aws-sdk-go-v2/aws/transport/http"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	iamType "github.com/aws/aws-sdk-go-v2/service/iam/types"
)

const (
	PolicyDescriptionPrefix = `Autogenerated policy by the AWS IAM Provisioner operator for cluster: `
)

func (c *IAMClient) generatePolicyARN(policyName *string) *string {
	policyARN := fmt.Sprintf("arn:aws:iam::%s:policy%s%s", c.AccountID, pathPrefix, *policyName)

	return &policyARN
}

func (c *IAMClient) BatchDeletePolicies(policies []iamType.Policy) error {
	for _, policy := range policies {
		if err := c.DeletePolicy(policy.PolicyName); err != nil {
			return err
		}
	}

	return nil
}

func (c *IAMClient) CreatePolicy(policyName, policyData, description *string, tags []iamType.Tag) (*iamType.Policy, error) {
	result, err := c.IAMClient.CreatePolicy(c.Ctx, &iam.CreatePolicyInput{
		Description:    description,
		Path:           aws.String(pathPrefix),
		PolicyDocument: policyData,
		PolicyName:     policyName,
		Tags:           tags,
	})
	if err != nil {
		var (
			respError           *awshttp.ResponseError
			entityAlreadyExists *iamType.EntityAlreadyExistsException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusConflict && respError.As(&entityAlreadyExists) {
			c.Logger.Info(fmt.Sprintf("creating skipped: a policy called %s already exists", *policyName))
			return nil, nil
		}

		return nil, err
	}

	c.Logger.Info(fmt.Sprintf("created policy %s", aws.ToString(result.Policy.PolicyName)))

	return result.Policy, nil
}

func (c *IAMClient) DeletePolicy(policyName *string) error {
	_, err := c.IAMClient.DeletePolicy(c.Ctx, &iam.DeletePolicyInput{
		PolicyArn: c.generatePolicyARN(policyName),
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("deleting skipped: policy %s was not found", *policyName))
			return nil
		}

		return err
	}

	c.Logger.Info(fmt.Sprintf("delete policy %s", *policyName))

	return nil
}

func (c *IAMClient) GetPolicyByName(policyName *string) (*iamType.Policy, bool, error) {
	result, err := c.IAMClient.GetPolicy(c.Ctx, &iam.GetPolicyInput{
		PolicyArn: c.generatePolicyARN(policyName),
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("policy %s was not found", *policyName))
			return nil, false, nil
		}

		return nil, false, err
	}

	return result.Policy, true, nil
}

func (c *IAMClient) ListPoliciesByTags(tags []iamType.Tag) ([]iamType.Policy, error) {
	var (
		params   *iam.ListPoliciesInput
		policies []iamType.Policy
	)

	params = &iam.ListPoliciesInput{
		MaxItems:          aws.Int32(50),
		PathPrefix:        aws.String(pathPrefix),
		PolicyUsageFilter: iamType.PolicyUsageTypePermissionsPolicy,
		Scope:             iamType.PolicyScopeTypeLocal,
	}

	policiesPaginator := iam.NewListPoliciesPaginator(c.IAMClient, params,
		func(options *iam.ListPoliciesPaginatorOptions) { options.StopOnDuplicateToken = true })
	for policiesPaginator.HasMorePages() {
		result, err := policiesPaginator.NextPage(c.Ctx)
		if err != nil {
			return nil, err
		} else {
			for _, policy := range result.Policies {
				similarTags, err := c.getSimilarPolicyTags(tags, policy)
				if err != nil {
					return nil, err
				}

				if compareTags(similarTags, tags) {
					policies = append(policies, policy)
				}
			}
		}
	}

	return policies, nil
}

func (c *IAMClient) ListEntitiesForPolicy(policy *iamType.Policy) ([]iamType.PolicyRole, error) {
	var (
		params *iam.ListEntitiesForPolicyInput
		roles  []iamType.PolicyRole
	)

	params = &iam.ListEntitiesForPolicyInput{
		PolicyArn:         policy.Arn,
		EntityFilter:      iamType.EntityTypeRole,
		MaxItems:          aws.Int32(10),
		PathPrefix:        aws.String(pathPrefix),
		PolicyUsageFilter: iamType.PolicyUsageTypePermissionsPolicy,
	}

	entitiesPaginator := iam.NewListEntitiesForPolicyPaginator(c.IAMClient, params,
		func(options *iam.ListEntitiesForPolicyPaginatorOptions) { options.StopOnDuplicateToken = true })
	for entitiesPaginator.HasMorePages() {
		result, err := entitiesPaginator.NextPage(c.Ctx)
		if err != nil {
			return nil, err
		} else {
			for _, role := range result.PolicyRoles {
				roles = append(roles, role)
			}
		}
	}

	return roles, nil
}
