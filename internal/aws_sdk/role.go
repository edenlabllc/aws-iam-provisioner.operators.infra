package aws_sdk

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"

	"github.com/aws/aws-sdk-go-v2/aws"
	awshttp "github.com/aws/aws-sdk-go-v2/aws/transport/http"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	iamType "github.com/aws/aws-sdk-go-v2/service/iam/types"
)

const (
	ButchAttachProc       = "attach"
	ButchDetachProc       = "detach"
	RoleDescriptionPrefix = `Autogenerated role by the AWS IAM Provisioner operator for cluster: `
)

func (c *IAMClient) AttachRolePolicy(policyName, roleName *string) error {
	_, err := c.IAMClient.AttachRolePolicy(c.Ctx, &iam.AttachRolePolicyInput{
		PolicyArn: c.generatePolicyARN(policyName),
		RoleName:  roleName,
	})
	if err != nil {
		return err
	}

	c.Logger.Info(fmt.Sprintf("attached policy %s to role %s", *policyName, *roleName))

	return nil
}

func (c *IAMClient) BatchAttachDetachRolePolicies(proc string, policies []iamType.Policy, roleName *string) error {
	for _, policy := range policies {
		switch proc {
		case ButchAttachProc:
			if err := c.AttachRolePolicy(policy.PolicyName, roleName); err != nil {
				return err
			}
		case ButchDetachProc:
			if err := c.DetachRolePolicy(policy.PolicyName, roleName); err != nil {
				return err
			}
		}
	}

	return nil
}

func (c *IAMClient) compactRolePolicyDocument(assumeRolePolicyDocument *string) (string, error) {
	unescape, err := url.PathUnescape(aws.ToString(assumeRolePolicyDocument))
	if err != nil {
		return "", err
	}

	var prettyJSON bytes.Buffer
	if err := json.Compact(&prettyJSON, []byte(unescape)); err != nil {
		return "", err
	}

	return prettyJSON.String(), nil
}

func (c *IAMClient) CreateRole(roleName, assumeRolePolicyDocument, description *string, tags []iamType.Tag) (*iamType.Role, error) {
	result, err := c.IAMClient.CreateRole(c.Ctx, &iam.CreateRoleInput{
		AssumeRolePolicyDocument: assumeRolePolicyDocument,
		Description:              description,
		RoleName:                 roleName,
		Path:                     aws.String(pathPrefix),
		Tags:                     tags,
	})
	if err != nil {
		var (
			respError           *awshttp.ResponseError
			entityAlreadyExists *iamType.EntityAlreadyExistsException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusConflict && respError.As(&entityAlreadyExists) {
			c.Logger.Info(fmt.Sprintf("creating skipped: a role called %s already exists", *roleName))
			return nil, nil
		}

		return nil, err
	}

	c.Logger.Info(fmt.Sprintf("created role %s", aws.ToString(result.Role.RoleName)))

	return result.Role, nil
}

func (c *IAMClient) DeleteRole(roleName *string) error {
	_, err := c.IAMClient.DeleteRole(c.Ctx, &iam.DeleteRoleInput{
		RoleName: roleName,
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("deleting skipped: policy %s was not found", *roleName))
			return nil
		}

		return err
	}

	c.Logger.Info(fmt.Sprintf("delete role %s", *roleName))

	return nil
}

func (c *IAMClient) DetachRolePolicy(policyName, roleName *string) error {
	_, err := c.IAMClient.DetachRolePolicy(c.Ctx, &iam.DetachRolePolicyInput{
		PolicyArn: c.generatePolicyARN(policyName),
		RoleName:  roleName,
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("detaching skipped: role %s was not found", *roleName))
			return nil
		}

		return err
	}

	c.Logger.Info(fmt.Sprintf("detached policy %s from role %s", *policyName, *roleName))

	return nil
}

func (c *IAMClient) DiffRoleByParams(rolePolicyDocumentA, rolePolicyDocumentB *string, tagsA, tagsB []iamType.Tag) (bool, error) {
	roleDocA, err := c.compactRolePolicyDocument(rolePolicyDocumentA)
	if err != nil {
		return false, err
	}

	roleDocB, err := c.compactRolePolicyDocument(rolePolicyDocumentB)
	if err != nil {
		return false, err
	}

	return roleDocA != roleDocB && compareTags(tagsA, tagsB), nil
}

func (c *IAMClient) GetRoleByName(roleName *string) (*iamType.Role, bool, error) {
	result, err := c.IAMClient.GetRole(c.Ctx, &iam.GetRoleInput{
		RoleName: roleName,
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("role %s was not found", *roleName))
			return nil, false, nil
		}

		return nil, false, err
	}

	return result.Role, true, nil
}

func (c *IAMClient) ListAttachedRolePolicies(roleName *string) ([]iamType.Policy, error) {
	var (
		params   *iam.ListAttachedRolePoliciesInput
		policies []iamType.Policy
	)

	params = &iam.ListAttachedRolePoliciesInput{
		MaxItems: aws.Int32(50),
		RoleName: roleName,
	}

	rolePoliciesPaginator := iam.NewListAttachedRolePoliciesPaginator(c.IAMClient, params,
		func(options *iam.ListAttachedRolePoliciesPaginatorOptions) { options.StopOnDuplicateToken = true })
	for rolePoliciesPaginator.HasMorePages() {
		result, err := rolePoliciesPaginator.NextPage(c.Ctx)
		if err != nil {
			return nil, err
		} else {
			for _, attachPolicy := range result.AttachedPolicies {
				policy, exists, err := c.GetPolicyByName(attachPolicy.PolicyName)
				if err != nil {
					return nil, err
				}

				if exists {
					policies = append(policies, *policy)
				}
			}
		}
	}

	return policies, nil
}

func (c *IAMClient) ListRolesByTags(tags []iamType.Tag) ([]iamType.Role, error) {
	var (
		params *iam.ListRolesInput
		roles  []iamType.Role
	)

	params = &iam.ListRolesInput{
		MaxItems:   aws.Int32(50),
		PathPrefix: aws.String(pathPrefix),
	}

	rolePaginator := iam.NewListRolesPaginator(c.IAMClient, params,
		func(options *iam.ListRolesPaginatorOptions) { options.StopOnDuplicateToken = true })
	for rolePaginator.HasMorePages() {
		result, err := rolePaginator.NextPage(c.Ctx)
		if err != nil {
			return nil, err
		} else {
			for _, role := range result.Roles {
				similarTags, err := c.getSimilarRoleTags(tags, role)
				if err != nil {
					return nil, err
				}

				if compareTags(similarTags, tags) {
					roles = append(roles, role)
				}
			}
		}
	}

	return roles, nil
}

func (c *IAMClient) UpdateRole(roleName, assumeRolePolicyDocument *string) error {
	_, err := c.IAMClient.UpdateAssumeRolePolicy(c.Ctx, &iam.UpdateAssumeRolePolicyInput{
		PolicyDocument: assumeRolePolicyDocument,
		RoleName:       roleName,
	})
	if err != nil {
		var (
			respError    *awshttp.ResponseError
			noSuchEntity *iamType.NoSuchEntityException
		)
		if errors.As(err, &respError) && respError.HTTPStatusCode() == http.StatusNotFound && respError.As(&noSuchEntity) {
			c.Logger.Info(fmt.Sprintf("updating skipped: role %s was not found", *roleName))
			return nil
		}

		return err
	}

	c.Logger.Info(fmt.Sprintf("updated trust relationship policy document for role %s", *roleName))

	return nil
}
